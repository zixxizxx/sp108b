## 第8章--重温并发。

同时获得良好的并行性能、不考虑并发性的正确性和可理解的代码是内核设计中的一大挑战。直接使用锁是通向正确性的最佳途径，但并不总是可行的。本章重点介绍了强制xv6以复杂的方式使用锁的示例，以及xv6使用类似锁的技术但不使用锁的示例。

### 8.1锁定模式。

高速缓存的项目通常难以锁定。例如，文件系统的块缓存(kernel/Bio.c：26)最多存储`NBUF‘磁盘块的副本。给定的磁盘块在缓存中最多只能有一个副本，这一点非常重要；否则，不同的进程可能会对应该是同一个块的不同副本进行冲突更改。每个缓存的块都存储在astruct buf(kernel/buf.h：1)中。

Astruct buf有一个锁定字段，它有助于确保一次只有一个进程使用给定的磁盘块。但是，锁定是不够的：如果缓存中根本不存在某个块，而两个进程想要同时使用它，该怎么办？没有nostruct buf(因为块还没有缓存)，因此没有什么需要锁定的。Xv6通过将另一个锁(bcache.lock)与缓存块的标识集相关联来处理这种情况。需要检查块是否被缓存的代码(例如，`bget`(kernel/bi.c：58))或更改缓存块的集合，必须持有bcache.lock；当该代码找到块并构造BUFIT需要后，它可以释放bcache.lock并仅锁定特定的块。(=。这是一种常见的模式：一组项目加一个锁，每个项目加一个锁。

通常，获取锁的同一函数将释放它。但是，更精确地看待事物的方法是，在必须显示为原子的序列开始时获取锁，并在该序列结束时释放锁。如果序列在不同的函数、不同的线程或不同的CPU中开始和结束，则锁获取和释放必须执行相同的操作。锁的功能是强制其他用途等待，而不是将一条数据固定到特定代理。一个例子是`yeeld`(kernel/proc.c：500)中的Acquisition，它在调度器线程中释放，而不是在获取过程中释放。另一个例子是`ilock`(kernel/fs.c：290)中的`quire`休眠；该代码经常在读磁盘时休眠；它可能在不同的CPU上唤醒，这意味着锁可能在不同的CPU上获取和释放。


释放由嵌入在对象中的锁保护的对象是一件微妙的事情，因为拥有锁并不足以保证释放是正确的。当其他线程在‘quire`中等待使用该对象时，就会出现问题；隐式释放该对象会释放嵌入的锁，这将导致等待的线程发生故障。一种解决方案是跟踪存在多少对该对象的引用，以便仅在最后一个引用消失时才释放该对象。例如，请参见seepipeclose(kernel/pipe.c：59)；`pi->readopen`和`pi->writeopen`跟踪管道是否有引用它的文件描述符。

### 8.2类锁图案。

在许多地方，xv6使用引用计数或标志作为一种软锁，以指示对象已分配，不应释放或重用。进程的‘p->state’是这样工作的，引用计数infile、inode和buf结构也是这样。虽然在每种情况下都有锁保护标志或引用计数，但正是后者防止对象过早释放。

文件系统使用`struct inode`引用计数作为一种可以由多个进程持有的共享锁，以避免代码使用普通锁时会出现的死锁。

例如，`namex`(kernel/fs.c：630)中的循环依次锁定每个路径名组件命名的目录。但是，`namex`必须在循环结束时释放每个锁，因为如果它持有多个锁，如果路径名包含一个点(例如，a/./b)，它可能会与自身死锁。它还可能因涉及目录和.的并发查找而死锁。正如第7章所解释的，解决方案是让循环将目录inode带到下一次迭代，同时其引用计数递增，但不锁定。

一些数据项在不同的时间由不同的机制保护，并且有时可以通过xv6代码的结构而不是显式锁来隐式地保护其不被并发访问。例如，当物理页面空闲时，它由kmem.lock(kernel/kalloc.c：24)保护。如果页面随后被分配为管道(kernel/pipe.c：23)，它将受到不同锁的保护(嵌入的`pi->lock`)。如果将该页重新分配给新进程的用户内存，则它根本不受锁保护。相反，分配器不会将该页提供给任何其他进程(直到它被释放)这一事实保护了它不会被并发访问。新进程内存的所有权很复杂：首先父进程在`fork`中分配和操作内存，然后子进程使用内存，(子进程退出后)父进程再次拥有内存并将其传递给`kfre`。这里有两个教训：数据对象在其生命周期的不同时间点可以用不同的方式保护其不被并发，保护可以采用隐式结构的形式，而不是显式锁的形式。

最后一个类似锁的示例是需要禁用mycpu()调用周围的中断(kernel/proc.c：66)。禁用中断会导致调用代码相对于计时器中断是原子的，这可能会强制上下文切换，从而将进程移到不同的CPU。

### 8.3完全不加锁。

在一些地方，xv6完全不加锁地共享可变数据。一个是自旋锁的实现，尽管可以将RISC-V原子指令视为依赖于硬件中实现的锁。另一个是main.c(kernel/main.c：7)中的started变量，用于防止其他CPU运行，直到CPU0完成对xv6的初始化；易失性确保编译器实际生成加载和存储指令。第三个是`proc.c`(kernel/proc.c：383)(kernel/proc.c：291)中`p->parent`的一些用法，正确的锁定可能会死锁，但显然没有其他进程可以同时修改`p->parent`。

第四个示例是`p->killed`，它是在保持`p->lock`(kernel/proc.c：596)的同时设置的，但是在没有持有锁(kernel/trap.c：56)的情况下进行检查。

Xv6包含这样的情况：一个CPU或线程写入一些数据，另一个CPU或线程读取数据，但是没有专门用于保护该数据的锁。例如，在fork中，父进程写入子进程的用户内存页面，子进程(一个不同的线程，可能在不同的CPU上)读取这些页面；没有锁显式地保护这些页面。严格来说，这并不是锁定问题，因为子进程直到父进程完成写入后才开始执行。这是一个潜在的内存排序问题(参见第5章)，因为没有内存屏障，就没有理由期望一个CPU看到另一个CPU的写入。但是，由于父进程释放锁，而子进程在启动时获取锁，所以`quire`和`release‘中的内存屏障确保子进程的CPU可以看到父进程的写操作。

### 8.4并行度。

锁定主要是为了保证正确性而抑制并行性。因为性能也很重要，内核设计人员经常必须考虑如何以一种既能实现正确性又能获得良好并行性的方式使用锁。虽然xv6没有系统地设计为高性能，但仍然值得考虑哪些xv6操作可以并行执行，哪些。
可能会在锁上发生冲突。

xv6中的管道就是一个相当好的并行性示例。每个管道都有自己的锁，因此不同的进程可以在不同的CPU上并行读写不同的管道。然而，对于给定的管道，写入器和读取器必须等待对方释放锁；它们不能同时读/写同一管道。在这种情况下，从空管道读取(或写入全管道)必须阻塞，但这不是由于锁定方案。

上下文切换是一个更复杂的示例。两个内核线程各自在自己的CPU上执行，可以同时调用`yeeld`、`Schedul`和`swtch`，这些调用将并行执行。

这些线程各自持有一个锁，但它们是不同的锁，因此它们不必相互等待。然而，一旦进入‘Scheduler’，当搜索进程表中的一个是‘RUNNABLE`’时，两个CPU可能会在锁上发生冲突。也就是说，在上下文切换期间，xv6可能会从多个CPU中获得性能优势，但可能不会达到最大程度。

另一个例子是不同CPU上的不同进程对`fork`的并发调用。调用可能需要等待`pid_lock`和`kmem.lock`，以及在进程表中搜索UNUSEDprocess所需的每进程锁。另一方面，这两个分叉进程可以并行复制用户内存页和完全格式化页表页。

上述每个示例中的锁定方案在某些情况下牺牲了并行性能。在每种情况下，都可以使用更精细的设计来获得更多的并行性。是否值得取决于细节：调用相关操作的频率、代码在持有争用锁的情况下花费多长时间、可能有多少CPU同时运行冲突的操作、代码的其他部分是否存在更多限制性瓶颈。很难猜测给定的锁定方案是否会导致性能问题，或者新的设计是否明显更好，因此通常需要对实际工作负载进行测量。

### 8.5练习。

1. 修改xv6的管道实现，以允许对同一管道的读取和写入在不同内核上并行进行。
2. 修改xv6的调度器()，以减少不同内核同时寻找可运行进程时的锁争用。
3. 消除xv6的fork()中的一些序列化。
